import random
import time
from collections import defaultdict
import heapq

# Clase para el árbol binario del torneo
class NodoTorneo:
    def __init__(self, personaje=None):
        self.personaje = personaje
        self.izquierdo = None
        self.derecho = None
        self.ganador = None

class ArbolTorneo:
    def __init__(self, profundidad):
        self.raiz = self._crear_arbol_vacio(profundidad)
        self.nivel_actual = profundidad
    
    def _crear_arbol_vacio(self, profundidad):
        if profundidad == 0:
            return NodoTorneo()
        nodo = NodoTorneo()
        nodo.izquierdo = self._crear_arbol_vacio(profundidad - 1)
        nodo.derecho = self._crear_arbol_vacio(profundidad - 1)
        return nodo
    
    def _insertar_participantes(self, nodo, participantes, nivel):
        if nivel == 0 and participantes:
            nodo.personaje = participantes.pop(0)
            return
        if nodo.izquierdo:
            self._insertar_participantes(nodo.izquierdo, participantes, nivel - 1)
        if nodo.derecho:
            self._insertar_participantes(nodo.derecho, participantes, nivel - 1)
    
    def insertar_participantes(self, participantes):
        participantes_copy = participantes.copy()
        for nivel in range(self.nivel_actual + 1):
            self._insertar_participantes(self.raiz, participantes_copy, nivel)
    
    def actualizar_ganador(self, nodo, ganador):
        if not nodo:
            return False
        if nodo.personaje == ganador:
            nodo.ganador = ganador
            return True
        if (nodo.izquierdo and nodo.izquierdo.personaje == ganador) or \
        (nodo.derecho and nodo.derecho.personaje == ganador):
            nodo.ganador = ganador
            return True
        return self.actualizar_ganador(nodo.izquierdo, ganador) or \
            self.actualizar_ganador(nodo.derecho, ganador)

# Clase Personaje base para todos los luchadores
class Personaje:
    def __init__(self, nombre, salud, poder_de_ataque, defensa, ataque_energia):
        self.nombre = nombre
        self.salud = salud
        self.poder_de_ataque = poder_de_ataque
        self.defensa = defensa
        self.turno_defensa = False
        self.puede_evolucionar = True
        self.ataque_energia = ataque_energia
    
    def atacar(self, otro_personaje, habilidad):
        if habilidad == "Piña":
            dano = self.poder_de_ataque * 1.1 - otro_personaje.defensa
            print(f"{self.nombre} usa Piña a {otro_personaje.nombre} y le causa {dano} puntos de daño.")
        elif habilidad == "Patada":
            dano = self.poder_de_ataque * 1.05 - otro_personaje.defensa
            print(f"{self.nombre} usa Patada a {otro_personaje.nombre} y le causa {dano} puntos de daño.")
        elif habilidad == "Ataque de Energía":
            dano = self.ataque_energia - otro_personaje.defensa
            print(f"{self.nombre} usa {self.nombre}'s Ataque de Energía a {otro_personaje.nombre} y le causa {dano} puntos de daño.")
        
        if dano > 0:
            otro_personaje.salud -= dano
        else:
            print(f"{self.nombre} usa {habilidad} pero el ataque es absorbido por la defensa de {otro_personaje.nombre}.")
    
    def defender(self, habilidad):
        if habilidad == "Cubrirse":
            probabilidad = 0.5 if self.poder_de_ataque <= 250 else 0.6 if self.poder_de_ataque <= 500 else 0.7
            if random.random() <= probabilidad:
                self.turno_defensa = True
                print(f"{self.nombre} se cubre con éxito, negando el próximo ataque.")
            else:
                print(f"{self.nombre} intenta cubrirse, pero no logra evitar el daño.")
        elif habilidad == "Mejorar":
            estadistica = random.choice(["salud", "defensa", "poder_de_ataque"])
            if estadistica == "salud":
                aumento = random.randint(30, 50)
                self.salud += aumento
                print(f"{self.nombre} mejora su salud en {aumento}. Salud actual: {self.salud}.")
            elif estadistica == "defensa":
                aumento = random.randint(5, 15)
                self.defensa += aumento
                print(f"{self.nombre} mejora su defensa en {aumento}. Defensa actual: {self.defensa}.")
            elif estadistica == "poder_de_ataque":
                aumento = random.randint(10, 20)
                self.poder_de_ataque += aumento
                print(f"{self.nombre} mejora su poder de ataque en {aumento}. Poder de ataque actual: {self.poder_de_ataque}.")
    
    def evolucionar(self):
        if self.puede_evolucionar:
            self.salud = self.salud * 1.15
            self.poder_de_ataque = self.poder_de_ataque * 1.15
            self.defensa = self.defensa * 1.15
            self.puede_evolucionar = False
            print(f"{self.nombre} evoluciona, todas sus estadísticas aumentan un 15%.")
        else:
            print(f"{self.nombre} ya no puede evolucionar, solo se puede usar una vez por batalla.")
    
    def esta_vivo(self):
        return self.salud > 0

# Clase para el modo aventura
class Planeta:
    def __init__(self, nombre, dificultad, beneficios):
        self.nombre = nombre
        self.dificultad = dificultad  # 1-5, afecta stats de enemigos
        self.beneficios = beneficios  # Dictionary con mejoras de stats
        self.enemigos = []
        self.completado = False

class ModoAventura:
    def __init__(self):
        self.planetas = {}
        self.grafo = defaultdict(list)
        self.inicializar_planetas()
        self.crear_conexiones()
    
    def inicializar_planetas(self):
        self.planetas = {
            "Tierra": Planeta("Tierra", 1, {
                "salud": 50,
                "poder_de_ataque": 10,
                "defensa": 5
            }),
            "Namek": Planeta("Namek", 2, {
                "salud": 100,
                "poder_de_ataque": 20,
                "defensa": 10,
                "ataque_energia": 30
            }),
            "Vegeta": Planeta("Vegeta", 3, {
                "salud": 150,
                "poder_de_ataque": 30,
                "defensa": 20,
                "ataque_energia": 50
            }),
            "Yardrat": Planeta("Yardrat", 4, {
                "salud": 200,
                "poder_de_ataque": 40,
                "defensa": 30,
                "ataque_energia": 70
            }),
            "Bills": Planeta("Bills", 5, {
                "salud": 300,
                "poder_de_ataque": 60,
                "defensa": 40,
                "ataque_energia": 100
            })
        }
        
        for planeta in self.planetas.values():
            self.generar_enemigos(planeta)
    
    def generar_enemigos(self, planeta):
        for i in range(5):
            multiplicador = planeta.dificultad
            enemigo = Personaje(
                f"Enemigo {i+1} de {planeta.nombre}",
                salud=300 * multiplicador,
                poder_de_ataque=40 * multiplicador,
                defensa=25 * multiplicador,
                ataque_energia=80 * multiplicador
            )
            planeta.enemigos.append(enemigo)
    
    def crear_conexiones(self):
        conexiones = [
            ("Tierra", "Namek", 4),
            ("Tierra", "Vegeta", 6),
            ("Namek", "Yardrat", 5),
            ("Namek", "Bills", 8),
            ("Vegeta", "Yardrat", 4),
            ("Vegeta", "Bills", 7),
            ("Yardrat", "Bills", 3)
        ]
        
        for origen, destino, costo in conexiones:
            self.grafo[origen].append((destino, costo))
            self.grafo[destino].append((origen, costo))
    
    def dijkstra(self, inicio, objetivo):
        distancias = {planeta: float('inf') for planeta in self.planetas}
        distancias[inicio] = 0
        pq = [(0, inicio)]
        camino = {planeta: None for planeta in self.planetas}
        
        while pq:
            dist_actual, actual = heapq.heappop(pq)
            
            if actual == objetivo:
                break
                
            if dist_actual > distancias[actual]:
                continue
                
            for vecino, peso in self.grafo[actual]:
                distancia = dist_actual + peso
                
                if distancia < distancias[vecino]:
                    distancias[vecino] = distancia
                    camino[vecino] = actual
                    heapq.heappush(pq, (distancia, vecino))
        
        return self.reconstruir_camino(camino, inicio, objetivo)
    
    def reconstruir_camino(self, camino, inicio, objetivo):
        ruta = []
        actual = objetivo
        
        while actual is not None:
            ruta.append(actual)
            actual = camino[actual]
        
        return list(reversed(ruta))
    
    def aplicar_beneficios(self, personaje, planeta):
        for stat, valor in self.planetas[planeta].beneficios.items():
            if hasattr(personaje, stat):
                setattr(personaje, stat, getattr(personaje, stat) + valor)
                print(f"{personaje.nombre} ha mejorado su {stat} en {valor} puntos en el planeta {planeta}!")
    
    def iniciar_aventura(self, goku):
        print("\n¡Bienvenido al Modo Aventura de Dragon Ball!")
        print("Goku deberá viajar por diferentes planetas, enfrentando enemigos y haciéndose más fuerte.")
        
        mejor_ruta = self.dijkstra("Tierra", "Bills")
        print("\nRuta óptima de planetas:", " -> ".join(mejor_ruta))
        
        for planeta_nombre in mejor_ruta:
            planeta = self.planetas[planeta_nombre]
            print(f"\n¡Llegando al planeta {planeta_nombre}!")
            print(f"Nivel de dificultad: {planeta.dificultad}/5")
            
            for i, enemigo in enumerate(planeta.enemigos, 1):
                print(f"\nBatalla {i} en {planeta_nombre}:")
                print(f"¡{goku.nombre} vs {enemigo.nombre}!")
                
                input("Presiona ENTER para comenzar la batalla...")
                
                ganador = batalla(goku, enemigo)
                if ganador != goku:
                    print(f"\n¡Game Over! {goku.nombre} ha sido derrotado en {planeta_nombre}.")
                    return False
                
                print(f"\n¡Victoria! {goku.nombre} ha derrotado a {enemigo.nombre}")
            
            planeta.completado = True
            self.aplicar_beneficios(goku, planeta_nombre)
            
            if planeta_nombre != "Bills":
                input("\nPresiona ENTER para viajar al siguiente planeta...")
        
        print(f"\n¡Felicidades! {goku.nombre} ha completado su aventura por todos los planetas!")
        return True

# Función de batalla que se usa tanto en el torneo como en la aventura
def batalla(personaje1, personaje2):
    while personaje1.esta_vivo() and personaje2.esta_vivo():
        print(f"\nTurno de {personaje1.nombre}:")
        habilidad1 = random.choice(["Piña", "Patada", "Ataque de Energía", "Cubrirse", "Mejorar", "Evolucionar"])
        if habilidad1 == "Evolucionar" and personaje1.puede_evolucionar:
            personaje1.evolucionar()
        elif habilidad1 in ["Piña", "Patada", "Ataque de Energía"]:
            if personaje2.turno_defensa:
                print(f"{personaje2.nombre} está cubriéndose, el ataque se niega.")
                personaje2.turno_defensa = False
            else:
                personaje1.atacar(personaje2, habilidad1)
        else:
            personaje1.defender(habilidad1)
        
        if not personaje2.esta_vivo():
            print(f"{personaje2.nombre} ha sido derrotado. {personaje1.nombre} gana la batalla.")
            return personaje1
        
        time.sleep(1)

        print(f"\nTurno de {personaje2.nombre}:")
        habilidad2 = random.choice(["Piña", "Patada", "Ataque de Energía", "Cubrirse", "Mejorar", "Evolucionar"])
        if habilidad2 == "Evolucionar" and personaje2.puede_evolucionar:
            personaje2.evolucionar()
        elif habilidad2 in ["Piña", "Patada", "Ataque de Energía"]:
            if personaje1.turno_defensa:
                print(f"{personaje1.nombre} está cubriéndose, el ataque se niega.")
                personaje1.turno_defensa = False
            else:
                personaje2.atacar(personaje1, habilidad2)
        else:
            personaje2.defender(habilidad2)

        if not personaje1.esta_vivo():
            print(f"{personaje1.nombre} ha sido derrotado. {personaje2.nombre} gana la batalla.")
            return personaje2
        
        time.sleep(1)

def torneo(personajes, cantidad):
    profundidad = 0
    while (1 << profundidad) < cantidad:
        profundidad += 1
    
    arbol_torneo = ArbolTorneo(profundidad)
    
    print("\n¿Cómo te gustaría elegir a los participantes?")
    print("1. Elección al azar")
    print("2. Elección personalizada")

def iniciar_modo_aventura():
    # Crear a Goku con stats base
    goku = Personaje("Goku", salud=500, poder_de_ataque=70, defensa=45, ataque_energia=150)
    
    # Iniciar la aventura
    aventura = ModoAventura()
    aventura.iniciar_aventura(goku)

# Lista de personajes disponibles
personajes = [
    Personaje("Raditz", salud=350, poder_de_ataque=50, defensa=30, ataque_energia=100),
    Personaje("Androide 17", salud=500, poder_de_ataque=60, defensa=40, ataque_energia=120),
    Personaje("Bardock (Super Saiyan)", salud=650, poder_de_ataque=75, defensa=50, ataque_energia=130),
    Personaje("Vegeta (Super Saiyan 4)", salud=800, poder_de_ataque=90, defensa=60, ataque_energia=160),
    Personaje("Goku (Super Saiyan 4)", salud=850, poder_de_ataque=95, defensa=65, ataque_energia=170),
    Personaje("Hit", salud=900, poder_de_ataque=100, defensa=70, ataque_energia=180),
    Personaje("Majin Buu (Kid Buu)", salud=1200, poder_de_ataque=120, defensa=80, ataque_energia=200),
    Personaje("Vegeta (Super Saiyan Blue Evolved)", salud=2000, poder_de_ataque=180, defensa=120, ataque_energia=300),
    Personaje("Frieza (Golden Form)", salud=2200, poder_de_ataque=200, defensa=130, ataque_energia=320),
    Personaje("Cell (Perfecto)", salud=2500, poder_de_ataque=220, defensa=150, ataque_energia=350),
    Personaje("Gohan (Místico)", salud=2700, poder_de_ataque=240, defensa=160, ataque_energia=380),
    Personaje("Trunks (Del Futuro)", salud=2800, poder_de_ataque=250, defensa=170, ataque_energia=400),
    Personaje("Zeno Sama", salud=10000, poder_de_ataque=700, defensa=350, ataque_energia=900)
]

# Menú principal del juego
def main():
    print("¡Bienvenidos al Juego de Dragon Ball Z!\n")
    print("Prepara tus habilidades y personajes para una aventura épica.")
    time.sleep(2)

    while True:
        print("\nSelecciona el modo de juego:")
        print("1. Modo Torneo")
        print("2. Modo Aventura")
        print("3. Salir")
        
        try:
            modo = int(input("Elige una opción (1-3): "))
            
            if modo == 1:
                cantidad_participantes = int(input("Elige el número de participantes (4, 8 o 16): "))
                if cantidad_participantes in [4, 8, 16]:
                    torneo(personajes, cantidad_participantes)
                else:
                    print("Número de participantes no válido. El torneo no puede comenzar.")
            elif modo == 2:
                iniciar_modo_aventura()
            elif modo == 3:
                print("\n¡Gracias por jugar! ¡Hasta la próxima!")
                break
            else:
                print("Opción no válida. Por favor, elige 1, 2 o 3.")
        except ValueError:
            print("Por favor, ingresa un número válido.")

if __name__ == "__main__":
    main()
